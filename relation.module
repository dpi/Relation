<?php

/**
 * @file
 * Describes relations between entities.
 */

/**
 * Implements hook_entity_info().
 */
function relation_entity_info() {
  $entities['relation'] = array(
    'label' => t('Relation'),
    'base table' => 'relation',
    'fieldable' => FALSE,
    'controller class' => 'RelationEntityController',
    'entity keys' => array(
      'id' => 'relation_id',
      'bundle' => 'predicate',
    ),
    'bundle keys' => array(
      'bundle' => 'predicate',
    ),
    'bundles' => array(),
    'view modes' => array(),
  );
  foreach (db_query('SELECT predicate, label, directional, transitive, min_arity, max_arity FROM {relation_type}') as $record) {
    $entities['relation']['bundles'][$record->predicate] = array(
      'label' => $record->label ? $record->label : $record->predicate,
      'directional' => $record->directional,
      'transitive' => $record->transitive,
      'min_arity' => $record->min_arity,
      'max_arity' => $record->max_arity,
    );
  }
  foreach (db_query('SELECT predicate, entity_type, bundle, r_index FROM {relation_bundles}') as $record) {
    $endpoint = $record->r_index ? 'target_bundles' : 'source_bundles';
    $entities['relation']['bundles'][$record->predicate][$endpoint][] = array(
      'entity_type' => $record->entity_type,
      'bundle'      => $record->bundle,
    );
  }
  return $entities;
}

/**
 * Implements hook_permission().
 */
function relation_permission() {
  return array(
    'administer relation' => array(
      'title' => t('Administer Relations'),
      'description' => t('Perform administration tasks for relations.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function relation_menu() {
  $items['relation/%relation'] = array(
    'access arguments' => array('access content'),
    'page callback' => 'relation_page',
    'page arguments' => array(1),
  );
  $items['admin/structure/relation'] = array(
    'title' => 'Relation',
    'access arguments' => array('administer relation'),
    'page callback' => 'relation_list',
  );
  $items['admin/structure/relation/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/structure/relation/add'] = array(
    'title' => 'Add',
    'access arguments' => array('administer relation'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('relation_config_page'),
    'type' => MENU_LOCAL_ACTION,
  );
  $items['admin/structure/relation/edit/%'] = array(
    'title' => 'Edit relation type',
    'access arguments' => array('administer relation'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('relation_config_page', 4),
    'type' => MENU_CALLBACK,
  );
  $items['relation/autocomplete/bundles'] = array(
    'type' => MENU_CALLBACK,
    'access arguments' => array('access content'),
    'page callback' => 'relation_predicate_autocomplete',
  );
  return $items;
}

/**
 * List all relation predicates.
 */
function relation_list() {
  $relation = relation_entity_info();
  $headers = array(t('Name'));
  $rows = array();
  foreach ($relation['relation']['bundles'] as $name => $bundle) {
    $url = url('admin/structure/relation/edit/' . $name);
    $link = t('<a href="!url">@label</a>', array('!url' => $url, '@label' => $bundle['label']));
    $rows[] = array($link);
  }
  $output = array(
    '#theme' => 'table',
    '#header' => $headers,
    '#rows' => $rows,
  );
  return $output;
}

/**
 * Relation bundle settings page.
 *
 * @param $predicate
 *   Relation type machine name. If this is not provided, assume that we're
 *   creating a new relation type.
 */
function relation_config_page($form, $form_state, $predicate = '') {
  $form['#write_record_keys'] = array();
  if ($predicate) {
    $relation_type = db_query('SELECT * FROM {relation_type} WHERE predicate = :predicate', array(':predicate' => $predicate))->fetchObject();
    if ($relation_type) {
      $form['#write_record_keys'][] = 'predicate';
      $relation_type->source_bundles = array();
      $relation_type->target_bundles = array();
      foreach (db_query('SELECT * FROM {relation_bundles} WHERE predicate = :predicate', array(':predicate' => $predicate)) as $record) {
        // if relation is non-directional, all indexes should be 0.
        if ($record->r_index == 0) {
          $relation_type->source_bundles[] = "$record->entity_type:$record->bundle";
        }
        elseif ($record->r_index == 1) {
          $relation_type->target_bundles[] = "$record->entity_type:$record->bundle";
        }

      }
    }
  }
  if (empty($relation_type)) {
    $relation_type = (object) array(
      'predicate' => $predicate,
      'label' => '',
      'bundles' => array(),
      'directional' => FALSE,
      'transitive' => FALSE,
      'min_arity' => 2,
      'max_arity' => 2,
      'source_bundles' => array(),
      'target_bundles' => array(),
    );
  }
  $predicate = $relation_type->predicate;
  $form['predicate'] = array(
    '#type'          => 'machine_name',
    '#title'         => t('Machine Name'),
    '#description'   => t('Machine name (predicate) of the relation'),
    '#default_value' => $predicate,
    '#required'      => TRUE,
    '#disabled'      => $predicate,
  );
  $form['label'] = array(
    '#type'          => 'textfield',
    '#title'         => t('Label'),
    '#description'   => t('Display name of the relation'),
    '#default_value' => $relation_type->label,
    '#required'      => TRUE,
  );
  $form['directional'] = array(
    '#type'           => 'checkbox',
    '#title'          => 'Directional',
    '#default_value'  => $relation_type->directional,
  );
  $form['transitive'] = array(
    '#type'           => 'checkbox',
    '#title'          => 'Transitive',
    '#default_value'  => $relation_type->transitive,
  );
  // these should probably be changed to numerical (validated) textfields.
  $options = array('2' => '2', '3' => '3', '4' => '4', '5' => '5', '8' => '8');
  $form['min_arity'] = array(
    '#type' => 'select',
    '#title' => t('Minimum Arity'),
    '#options' => $options,
    '#description' => t('Minimum number of entities joined by the relation (e.g. three siblings in one relation). <em>In nearly all cases you will want to leave this set to 2</em>.'),
    '#default_value' => $relation_type->min_arity ? $relation_type->min_arity : 2,
    '#states' => array(
      'disabled' => array(   // action to take.
        ':input[name="directional"]' => array('checked' => TRUE),
      ),
    ),
  );

  $options = array('2' => '2', '3' => '3', '4' => '4', '5' => '5', '8' => '8', '0' => t('Infinite'));
  $form['max_arity'] = array(
    '#type' => 'select',
    '#title' => t('Maximum Arity'),
    '#options' => $options,
    '#description' => t('Maximum number of entities joined by the relation. <em>In nearly all cases you will want to leave this set to 2</em>.'),
    '#default_value' => $relation_type->max_arity ? $relation_type->max_arity : 2,
    '#states' => array(
      'disabled' => array(   // action to take.
        ':input[name="directional"]' => array('checked' => TRUE),
      ),
    ),
  );
  $counter = 0;
  foreach (module_invoke_all('entity_info') as $entity_type => $entity) {
    if (isset($entity['bundles'])) {
      foreach ($entity['bundles'] as $bundle_id => $bundle) {
        $bundles[$entity['label']]["$entity_type:$bundle_id"] = $bundle['label'];
        $counter++;
      }
    }
    else {
      $bundles[$entity['label']]["$entity_type:$entity_type"] = $entity['label'];
        $counter++;
    }
  }
  $form['source_bundles'] = array(
    '#type'          => 'select',
    '#title'         => 'Available source bundles',
    '#options'       => $bundles,
    '#size'          => max(12, $counter),
    '#default_value' => $relation_type->source_bundles,
    '#multiple'      => TRUE,
    '#description'   => 'Bundles that are not selected will not be available as sources for directional, or end points of non-directional relations relations. Ctrl+click to select multiple.',
  );
  $form['target_bundles'] = array(
    '#type'          => 'select',
    '#title'         => 'Available target bundles',
    '#options'       => $bundles,
    '#size'          => max(12, $counter),
    '#default_value' => $relation_type->target_bundles,
    '#multiple'      => TRUE,
    '#description'   => 'Bundles that are not selected will not be available as targets for directional relations. Ctrl+click to select multiple.',
    '#states' => array(
      '!visible' => array(   // action to take.
        ':input[name="directional"]' => array('checked' => FALSE),
      ),
    ),
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save')
  );
  return $form;
}

/**
 * Submit data from bundle settings page.
 */
function relation_config_page_submit($form, &$form_state) {
  $predicate = $form_state['values']['predicate'];
  $min_arity = $form_state['values']['directional'] ? 2 : $form_state['values']['min_arity'];
  $max_arity = $form_state['values']['directional'] ? 2 : $form_state['values']['max_arity'];
  $record = array(
    'predicate'   => $predicate,
    'min_arity'   => $min_arity,
    'max_arity'   => $max_arity,
    'label' => $form_state['values']['label'],
    'directional' => $form_state['values']['directional'],
    'transitive' => $form_state['values']['transitive'],
    'source_bundles' => $form_state['values']['source_bundles'],
    'target_bundles' => $form_state['values']['target_bundles'],
  );
  relation_type_save($record, $form['#write_record_keys']);
  $form_state['redirect'] = "admin/structure/relation/edit/$predicate";
}

/**
 * Save relation bundle.
 *
 * @param $record
 *   Array containing:
 *   - predicate: Relation type machine name (string).
 *   - label: Relation type human-readable name (string).
 *   - directional: whether relation is directional (boolean) .
 *   - transitive: whether relation is transitive (boolean).
 *   - min_arity: minimum number of entities in relations of this type (int>=2).
 *   - max_arity: maximum number of entities in relations of this type (int>=min_arity).
 *   - source_bundles: array containing allowed bundle keys. This is used for
 *     both directional and non-directional relations. Bundle key arrays are
 *     made up of of the form 'entity:bundle', eg. 'node:article'.
 *   - target_bundles: array containing arrays allowed target bundle keys.
 *     This is the same format as source_bundles, but is only used for
 *     directional relations.
 * @param $write_record_keys
 *   Array containing the primary key of the relation ('predicate'), if we are
 *   updating a relation, or an empty array if we are creating a new relation.
 */
function relation_type_save($record, $write_record_keys = array()) {
dpm($record, 'record');
dpm($write_record_keys, 'WRK');
  $record += array(
    'min_arity' => 2,
    'max_arity' => 2,
    'directional' => FALSE,
    'transitive' => FALSE,
  );
  $source_bundles = $record['source_bundles'];
  if ($record['directional']) {
    $target_bundles = $record['target_bundles'];
  }
  unset($record['source_bundles'], $record['target_bundles']);
  $predicate = $record['predicate'];
  $transaction = db_transaction();
  drupal_write_record('relation_type', $record, $write_record_keys);
  db_delete('relation_bundles')->condition('predicate', $predicate)->execute();
  $query = db_insert('relation_bundles')->fields(array('predicate', 'entity_type', 'bundle', 'r_index'));
  foreach ($source_bundles as $entity_bundles) {
    list($entity_type, $bundle) = explode(':', $entity_bundles, 2);
    $query->values(array($predicate, $entity_type, $bundle, 0));
  }
  if ($record['directional']) {
    foreach ($target_bundles as $entity_bundles) {
      list($entity_type, $bundle) = explode(':', $entity_bundles, 2);
      $query->values(array($predicate, $entity_type, $bundle, 1));
    }
  }
  $query->execute();
}

/**
 * Load a relation from a relation_id.
 *
 * @param $relation_id
 *   Numerical relation_id of the relation to be loaded.
 *
 * @return
 *   Loaded relation object.
 */
function relation_load($relation_id) {
  return reset(relation_multiple_load(array($relation_id)));
}

/**
 * Load an set of relations from an array of relation_ids.
 *
 * @param $relation_ids
 *   Array of numerical relation_ids of the relations to be loaded.
 *
 * @return
 *   Associative array of loaded relation objects, keyed by relation_id.
 */
function relation_multiple_load($relation_ids) {
  // Entity load handles field_attach_load for us.
  return entity_load('relation', $relation_ids);
}

/**
 * Relation display page. Currently only displays related entities.
 *
 * @TODO: implement directionality, possibly give more details on entities?
 */
function relation_page($relation) {
  foreach ($relation->entity_keys as $r_index => $entity_key) {
    $entity_keys = entity_load($entity_data['entity_type'], array($entity_data['entity_id']));
    $entity = $entity_keys[$entity_data['entity_id']];
    $label = entity_label($entity_data['entity_type'], $entity);
    $uri = entity_uri($entity_data['entity_type'], $entity);
    $items[$r_index] = l($label, $uri['path'], $uri['options']);
  }
  $build['link_list'] = array(
    '#theme' => 'item_list',
    '#items' => $items,
  );
  return $build;
}

/**
 * Controller class for entity relations.
 *
 * This extends the DrupalDefaultEntityController class. The buildQuery method
 * is overriden to add the self join and to exclude rows where the left and
 * right entities are identical.
 */
class RelationEntityController extends DrupalDefaultEntityController {

  /**
   * Add related entity data to relation. Each entity is saved as an
   * (entity_type, entity_id, r_index) triple.
   */
  protected function attachLoad(&$queried_entities, $revision_id = FALSE) {
    parent::attachLoad($queried_entities, $revision_id);
    foreach ($queried_entities as $id => $entity) {
      $query = db_select('relation', 'r');
      $query->condition('r.relation_id', $id);
      $query->innerJoin('relation_data', 'rd', 'r.relation_id = rd.relation_id');
      $query->addField('r', 'relation_id');
      $query->addField('r', 'predicate');
      $query->addField('rd', 'entity_type', 'entity_type');
      $query->addField('rd', 'entity_id', 'entity_id');
      $query->addField('rd', 'r_index', 'r_index');
      $results = $query->execute();
      $rows = $results->fetchAll();
      foreach ($rows as $row) {
        $queried_entities[$id]->entity_keys[$row->r_index] = array(
          'entity_type' => $row->entity_type,
          'entity_id' => $row->entity_id,
          'r_index' => $row->r_index,
        );
      }
    }
  }
}

/**
 * Interface for relation handlers.
 */
interface RelationInterface {
  // bangpound
  public function getRelated($entity, $type);

  // becw
  function init($left, $right); // sets types
  function set_left($entity_ids = array()); // sets left objects
  function set_right($entity_ids = array()); // sets right objects
  function get_left(); // returns left
  function get_right(); // returns right
}

/**
 * Handler class for entity relations.
 */
class RelationHandler implements RelationInterface {

  function __construct() {
  }

  /**
   * Entity is a fully loaded entity (node, user, term, etc.)
   * Type is the predicate.
   */
  public function getRelated($entity, $type) {
    return NULL;
  }

  function init($left, $right) {
  }

  function set_left($entity_ids = array()) {
  }

  function set_right($entity_ids = array()) {
  }

  function get_left() {
  }

  function get_right() {
  }
}

/**
 * Create a relation.
 *
 * @param $predicate
 *   The relation type (bundle) of the relation to be created.
 * @param $entity_keys
 *   A list of (entity_type, entity_id) pairs.
 *
 * @return
 *   The new relation id.
 */
function relation_create($predicate, $entity_keys) {
  $relation_id = db_insert('relation')
    ->useDefaults(array('relation_id'))
    ->fields(array('predicate' => $predicate, 'arity' => count($entity_keys)))
    ->execute();
  $query = db_insert('relation_data')
    ->fields(array('relation_id', 'entity_type', 'entity_id', 'r_index'));
  foreach ($entity_keys as $index => $entity_key) {
    $query->values(array($relation_id, $entity_key['entity_type'], $entity_key['entity_id'], $index));
  }
  $query->execute();
  return $relation_id;
}

/**
 * Generic relation validation.
 *
 * @param $predicate
 *   Relation type machine name (predicate).
 * @param $entity_keys
 *   An array of entity key arrays of the form:
 *   - entity_type: type of the entity to be added to the relation (eg. node)
 *   - entity_id: numerical id of the entity to be added to the relation.
 *   - r_index: integer index of the entity to be added. This should be zero if
 *     the relation is non-directional.
 * @param $error
 *   Array of errors passed by reference.
 */
function relation_validate($predicate, $entity_keys, &$errors) {
  $relation_type = db_query('SELECT directional, min_arity, max_arity FROM {relation_type} WHERE predicate = :predicate', array(':predicate' => $predicate))->fetchObject();
  // Check that predicate exists.
  if (!$relation_type) {
    $errors[] = t("The :predicate relation type does not exist!", array(':predicate' => $predicate));
  }
  // Check that arity is within acceptable bounds.
  if (count($entity_keys) < $relation_type->min_arity) {
    $errors[] = t("Relation has too few end points (:predicate min arity :min_arity)", array(':predicate' => $predicate, ':min_arity' => $relation_type->min_arity));
  }
  if (count($entity_keys) > $relation_type->max_arity) {
    $errors[] = t("Relation has too many end points (:predicate max arity :max_arity)", array(':predicate' => $predicate, ':min_arity' => $relation_type->max_arity));
  }
  //Check that each entity is has acceptable bundle type and index.
  $relation_bundles = relation_get_bundles($predicate);
  foreach ($entity_keys as $entity_key) {
    $acceptable = FALSE;
    // This is the only way have to get bundles from entity type and id as the
    // entity info is about the loaded entity not some database columns.
    $entities = entity_load($entity_key['entity_type'], array($entity_key['entity_id']));
    $entity = $entities[$entity_key['entity_id']];
    list(, , $entity_bundle) = entity_extract_ids($entity_key['entity_type'], $entity);
    $direction = isset($entity_key['r_index']) ? $entity_key['r_index'] : 0;
    $endpoint =  ($direction > 0) ? 'target' : 'source';
    foreach ($relation_bundles[$endpoint . '_bundles'] as $relation_bundle) {
      if (($entity_key['entity_type'] == $relation_bundle['entity_type']) && ($entity_bundle == $relation_bundle['bundle'])) {
        $acceptable = TRUE;
        break;
      }
    }
    if (!$acceptable) {
      $endpoint = $relation_type->directional ? $endpoint . ' endpoints' : 'an endpoint';
      $errors[] = t("The <em>:predicate</em> relation type does not allow :bundle entities as $endpoint.", array(':predicate' => $predicate, ':bundle' => $entity_bundle));
    }
  }
}

/**
 * Implements hook_block_info().
 */
function relation_block_info() {
  return array(
    'dropzone' => array(
      'info' => t('Relation block'),
    ),
  );
}

/**
 * Implements hook_block_view().
 */
function relation_block_view() {
  drupal_add_css(drupal_get_path('module', 'relation') . '/relation.css');

  $form = drupal_get_form('relation_dropzone');
  if (isset($form['entity_key'])) {
    return array(
      'subject' => t('Pick an entity'),
      'content' => $form,
    );
  }
  return array();
}

/**
 * The dropzone form.
 */
function relation_dropzone($form) {
  $options = array();
  foreach (drupal_static('relation_entities', array()) as $entity_type => $entities) {
    foreach ($entities as $entity_id => $entity) {
      $options["$entity_type:$entity_id"] = "$entity_type: " . entity_label($entity_type, $entity);
    }
  }
  if ($options) {
    $form['predicate'] = array(
      '#type'          => 'textfield',
      '#title'         => t('Predicate'),
      '#description'   => 'Name of the relation',
      '#autocomplete_path' => 'relation/autocomplete/bundles',
      '#default_value' => isset($_SESSION['relation_predicate']) ? $_SESSION['relation_predicate'] : '',
      '#required'      => TRUE,
    );
    $form['entity_key'] = array(
      '#type'         => 'select',
      '#options'      => $options,
      '#default_value' => '',
    );
    if (count($options) > 1) {
      $form['entity_key']['#empty_value'] = '';
      $form['entity_key']['#empty_option'] = t('Select an entity');
    }
    $form['pick'] = array(
      '#type' => 'submit',
      '#submit' => array('relation_dropzone_pick'),
      '#value' => t('Pick'),
    );
    if (!empty($_SESSION['relation_entity_keys'])) {
      $form['stored'] = _relation_stored_entity_keys_list();
      $form['save'] = array(
        '#type' => 'submit',
        '#value' => t('Create relation'),
        '#submit' => array('relation_dropzone_save'),
      );
      if (isset($_SESSION['relation_entity_keys'])) {
        $form['clear'] = array(
          '#type' => 'submit',
          '#value' => t('Clear'),
          '#submit' => array('relation_dropzone_clear'),
        );
      }
    }
  }
  return $form;
}

/**
 * Helper to get a item_list render structure out of the entities in session.
 */
function _relation_stored_entity_keys_list() {
  $list = array();
  foreach ($_SESSION['relation_entity_keys'] as $entity_key) {
    // The structure is (entity_type, entity_id, entity label).
    $list[] = $entity_key['entity_key'];
  }
  return array(
    '#theme' => 'item_list',
    '#items' => $list,
  );
}

/**
 * Submit handler for the pick button.
 */
function relation_dropzone_pick($form, &$form_state) {
  if ($entity_key = $form_state['values']['entity_key']) {
    $form_state['values']['entity_key'] = '';
    // Here we get (entity_type, entity_id).
    $break = explode(':', $entity_key);
    // Add the label for later display. #options is check_plain'd but we need
    // to do that ourselves.
    $pick = array(
      'entity_type' => $break[0],
      'entity_id' => $break[1],
      'entity_key' => check_plain($form['entity_key']['#options'][$entity_key]),
    );
    $_SESSION += array('relation_entity_keys' => array());
    $_SESSION['relation_entity_keys'][] = $pick;
    $_SESSION['relation_predicate'] = $form_state['values']['predicate'];
  }
}

/**
 * Validate form submission for the dropzone.
 */
function relation_dropzone_validate($form, &$form_state) {
  $predicate = $form_state['values']['predicate'];
  // May need some separate validation for "pick"
  if ($form_state['clicked_button']['#value']=='Create relation') {
    $errors = array();
    relation_validate($predicate, $_SESSION['relation_entity_keys'], $errors);
    foreach ($errors as $error) {
      form_set_error('predicate', $error);
    }
  }
}

/**
 * Submit handler for the save button.
 */
function relation_dropzone_save($form, $form_state) {
  if (isset($_SESSION['relation_predicate'])) {
    $predicate = $_SESSION['relation_predicate'];
    $relation_id = relation_create($predicate, $_SESSION['relation_entity_keys']);
    $link = l($predicate, "relation/$relation_id");
    $list = drupal_render(_relation_stored_entity_keys_list());
    $message = t('Created new !link from !list.', array('!link' => $link, '!list' => $list));
    drupal_set_message($message);
    relation_dropzone_clear($form, $form_state);
  }
}

/**
 * Submit handler for the clear button.
 */
function relation_dropzone_clear($form, $form_state) {
  unset($_SESSION['relation_predicate'], $_SESSION['relation_entity_keys']);
}

/**
 * Implements hook_entity_load().
 */
function relation_entity_load($entities, $type) {
  $entities_store = &drupal_static('relation_entities', array());
  $enabled = &drupal_static(__FUNCTION__);
  // Recursion protection.
  if ($enabled === -1) {
    return;
  }
  if (!isset($enabled)) {
    $enabled = -1;
    drupal_theme_initialize();
    $block_info = _block_load_blocks();
    $enabled = FALSE;
    foreach ($block_info as $region => $blocks) {
      if (isset($blocks['relation_dropzone'])) {
        $enabled = TRUE;
        break;
      }
    }
  }
  if ($enabled) {
    $entities_store += array($type => array());
    $entities_store[$type] += $entities;
  }
}

/**
 * Autocomplete page for listing bundles.
 */
function relation_predicate_autocomplete($string='') {
  $sql = "SELECT predicate, label FROM {relation_type} WHERE lower(predicate) LIKE lower('%" . $string . "%')";

  $resource = db_query($sql);
  $results = array();
  foreach ($resource as $row) {
    $results[$row->predicate] = $row->label;
  }
  print drupal_json_encode($results);
  exit();
}

/**
 * Helper query to get all relations tied to an entity.
 *
 * @param $entity_type
 *   The type of the entity (eg. node).
 * @param $entity_id
 *   The numerical entity id.
 * @param $predicates
 *   Array of relation types to look for.
 * @param $index
 *   The index of the entity in the relation, ie. for finding only relations
 *   for which the given entity is a target endpoint.
 *
 * @return
 *   Array of relation entity objects (which contain all the entities that they
 *   relate). Array is empty if no relations are found.
 */
function relation_get_relations($entity_type, $entity_id, $predicates = array(), $index = NULL) {
  $query = db_select('relation_data', 'rd');
  $query->addField('r', 'relation_id');
  $query->innerJoin('relation', 'r', 'r.relation_id = rd.relation_id');
  $query->condition('rd.entity_id', $entity_id);
  if ($predicates) {
    $query->condition('r.predicate', $predicates);
  }
  if (isset($index)) {
    $query->condition('rd.index', $index);
  }
  $relation_ids = $query->execute()->fetchCol();
  return $relation_ids ? entity_load('relation', $relation_ids) : array();
}

/**
 * Helper query to get all bundles available to relation.
 *
 * @param $predicate
 *   Machine name of the relation.
 *
 * @return
 *   An array with two sub-arrays, for source and target bundles. If relation
 *   is non-directional, all bundles are returned in 'source_bundles'.
 */
function relation_get_bundles($predicate) {
  $bundles = db_query('SELECT * FROM {relation_bundles} WHERE predicate = :predicate', array(':predicate' => $predicate))->fetchAll();
  $relation = array('source_bundles' => array(), 'target_bundles' => array());
  foreach ($bundles as $bundle) {
    $endpoint = $bundle->r_index ? 'target_bundles' : 'source_bundles';
    $relation[$endpoint][] = array(
      'entity_type' => $bundle->entity_type,
      'bundle'      => $bundle->bundle,
    );
  }
  return $relation;
}
