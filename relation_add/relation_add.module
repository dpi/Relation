<?php

/**
 * Implements hook_menu().
 */
function relation_add_menu() {
  $items['relation_add/autocomplete/%'] = array(
    'access callback' => TRUE,
    'page callback' => 'relation_add_autocomplete',
    'page arguments' => array(2, 3),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_block_info().
 */
function relation_add_block_info() {
  return array(
    'block' => array(
      'info' => t('Relation Add'),
    ),
  );
}

/**
 * Implements hook_block_view().
 */
function relation_add_block_view() {

  $block['subject'] = t('Relation Add');
  $block['content'] = drupal_get_form('relation_add_block_form');
  return $block;
}

/**
 * The relation add block form.
 */
function relation_add_block_form($form, &$form_state) {
  $form['#attached']['css'] = array(
    drupal_get_path('module', 'relation_add') . '/relation_add.css',
  );

  // Get the entity for the current page. This fails for taxonomy entities.
  // Need a better way. Also, this will never really work for comments, or
  // files, or other entities that don't have their own page.
  $all_entities = array_keys(entity_get_info());
  $path = menu_get_item();

  if (count($path['map']) >= 2 && in_array($path['map'][0], $all_entities) && is_object($path['map'][1])) {
    $entity_type = $path['map'][0];
    $current_entity = $path['map'][1];
  }
  elseif (count($path['map']) >= 3 && $path['map'][0] == 'taxonomy' && is_object($path['map'][2])) {
    $entity_type = 'taxonomy_term';
    $current_entity = $path['map'][2];
  }

  // Act as helper block if no relation types are defined.
  $relation_types = relation_get_types();
  if (empty($relation_types)) {
    $form['explanation']['#markup'] = t('Before you can create relations, you need to create one or more !link. Once you\'ve done that, visit any page displays an entity, and use this block to add  a new relation from that entity.', array('!link' => l('relation types', 'admin/structure/relation')));
    return $form;
  }

  //if (!isset($form_state['triggering_element']['#ajax']) && !isset($current_entity)) {

  if (isset($form_state['values']['current_entity'])) {
    $value = $form_state['values']['current_entity'];
  }
  elseif (isset($current_entity)) {
    $current_label = entity_label($entity_type, $current_entity);
    list($id, $vid, $bundle) = entity_extract_ids($entity_type, $current_entity);
    $value = $current_label . ' [' . $entity_type . ':' . $id . ']';
  }
  else {
    $form['explanation']['#markup'] = t('No entity found, can\'t create a relation!');
    return $form;
  }

  $form['current_entity'] = array(
    '#type'           => 'textfield',
    '#title'          => t('Create a relation from'),
    '#value'          => $value,
    '#disabled'       => TRUE,
  );

  // Relation type selector. On change, rest of form is loaded via ajax.
  $relation_types = relation_get_available_types();
  $types = array();
  foreach ($relation_types as $relation_type) {
    $types[$relation_type->relation_type] = $relation_type->label;
  }
  $default = !empty($form_state['values']['relation_type']) ? $form_state['values']['relation_type'] : '';
  $form['relation_type'] = array(
    '#type'          => 'select',
    '#title'         => t('Relation type'),
    '#default_value' => $default,
    '#options'       => $types,
    '#empty_value'   => '',
    '#empty_option'  => t('Select a relation type'),
    '#ajax' => array(
      'callback' => 'relation_add_ajax',
      'wrapper' => 'relation-add-options',
      'method' => 'replace',
      'effect' => 'fade',
    ),
  );
  $form['relation_options'] = array(
//    '#type'           => 'fieldset',
//    '#title'          => t('Relation options'),
    '#prefix' => '<div id="relation-add-options">',
    '#suffix' => '</div>',
  );

  // AJAXification.
  if (!empty($form_state['values']['relation_type'])) {
    $type = $form_state['values']['relation_type'];
    $relation_type = relation_type_load($type);
    $relation = (object) relation_create($type, array());

    for ($i = 2; $i <= $relation_type->max_arity; $i++ ) {
      $form['relation_options']['targets']['target_' . $i] = array(
        '#type' => 'textfield',
        '#title' => t('Endpoint ' . $i),
        '#autocomplete_path' => 'relation_add/autocomplete/' . $type,
      );
    }
    field_attach_form('relation', $relation, $form['relation_options'], $form_state);
    unset($form['relation_options']['endpoints']);

    $form['relation_options']['save'] = array(
      '#type'   => 'submit',
      '#weight' => 100,
      '#value'  => t('Create relation'),
      '#submit' => array('relation_add_save'),
    );
  }

  else {
    $form['relation_options']['explanation'] = array(
      '#prefix' => '<div id=\'relation-add-explanation\'>',
      '#markup' => t('This block allows you to create a relation from the current entity (the one displayed on this page), to another one. Please select a relation type.'),
      '#suffix' => '</div>',
    );
  }

  return $form;
}

/**
 * AJAX callback for block form.
 */
function relation_add_ajax($form, $form_state) {
  return $form['relation_options'];
}

/**
 * Validate form submission for the relation add block form.
 */
//function relation_add_validate($form, &$form_state) {
//  TODO
//  $type =
//  $entity_keys =
//  relation_create($type, $entity_keys);
//  field_attach_form_validate('relation', $relation, $form['relation_options'], $form_state);
//}

/**
 * Submit handler for the save button.
 */
function relation_add_save($form, &$form_state) {
  $type = $form_state['values']['relation_type'];
  $entity_strings = array($form_state['values']['current_entity']);
  for ($i = 2; $i; $i++) {
    if (isset($form_state['values']['target_' . $i])) {
      $entity_strings[] = $form_state['values']['target_' . $i];
    }
    else {
      $i = FALSE; // break loop.
    }
  }
  $entity_keys = array();
  foreach ($entity_strings as $r_index => $entity_string) {
    $matches = array();
    preg_match('/([\w\s]*)\[([\w\d]+):(\d+)\]/', $entity_string, $matches);
    if ($matches) {
      $entity_keys[] = array(
        'entity_label' => $matches[1],
        'entity_type' => $matches[2],
        'entity_id'   => $matches[3],
        'r_index'     => $r_index,
      );
    }
  }
  // TODO: IF count(entity_keys) != count (entity_strings), FAIL.

  $relation = relation_create($type, $entity_keys);
  entity_form_submit_build_entity('relation', $relation, $form['relation_options'], $form_state);
  $rid = relation_save($relation);

  if ($rid) {
    $link = l($type, "relation/$rid");
    // See also _relation_stored_entity_keys_list() in relation_entity_collector.module
    $list = array('#theme' => 'item_list', '#items' => array());
    foreach ($entity_keys as $entity_key) {
      $list['#items'][] = $entity_key['entity_label'];
    }
    $rendered_list = drupal_render($list);
    $message = t('Created new !link from !list', array('!link' => $link, '!list' => $rendered_list));
    drupal_set_message($message);
  }
  else {
    drupal_set_message('Relation not created.', 'error');
  }
}


/**
 * Autocomplete page for listing entities appropriate for a giver relation type.
 *
 * @param $type
 *   The relation type to search for endpoints for.
 * @param $string
 *   The string for which the search through entity labels will be run.
 */
function relation_add_autocomplete($type = '', $string = '') {
  // Would be nice to make a way for this to work for the source bundles of directional relations
  if (empty($type) || empty($string)) {
    exit();
  }
  $entity_infos = entity_get_info();
  $relation_type = relation_type_load($type);
  $entity_bundles = array();
  $direction = $relation_type->directional ? 'target_bundles' : 'source_bundles';
  foreach ($relation_type->$direction as $entity_bundle) {
    list($entity_type, $bundle) = explode(':', $entity_bundle, 2);
    $entity_bundles[$entity_type][] = $bundle;
  }
  // Get about 12, rounded up.
  $limit = ceil(12 / count(array_keys($entity_bundles)));
  $suggestions = array();
  foreach ($entity_bundles as $entity_type => $bundles) {
    $base_table = $entity_infos[$entity_type]['base table'];
    // Get the name of the column in the base table for the entity type.
    if ($entity_type == 'user') { // Special case for users.
      $label_key = 'name';
    }
    elseif (isset($entity_infos[$entity_type]['entity keys']['label'])) {
      $label_key = $entity_infos[$entity_type]['entity keys']['label'];
    }
    else {
      break; // Can't find a label to search over, give up.
    }
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', $entity_type)
      ->propertyCondition($label_key, $string, 'CONTAINS')
      ->range(0, $limit);
    if (!in_array('*', $bundles)) {
      $query->entityCondition('bundle', $bundles, 'IN');
    }
    if ($results = $query->execute()) {
      foreach (array_keys($results[$entity_type]) as $id) {
        $entities = entity_load($entity_type, array($id));
        $entity = reset($entities);
        $label = entity_label($entity_type, $entity);
        $suggestions[$label . ' [' . $entity_type . ':' . $id . ']'] = $label  . ' [' . $entity_type . ':' . $id . ']';
      }
    }
  }
  print drupal_json_encode($suggestions);
  exit();
}

