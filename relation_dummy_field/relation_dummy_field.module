<?php

/**
 * @file
 * A field storing arbitrary relations between entities.
 */

/**
 * Implements hook_menu().
 */
function relation_dummy_field_menu() {
  $items['relation_dummy_field/autocomplete/%/%'] = array(
    // Tricky question, this one is. But, EFQ + entity_load will take care a
    // lot of problems.
    'access callback' => TRUE,
    'page callback' => 'relation_dummy_field_autocomplete',
    'page arguments' => array(2, 3),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_field_info().
 */
function relation_dummy_field_field_info() {
  return array(
    'relation' => array(
      'label' => t('Relation'),
      'description' => t('Stores relationships between entities.'),
      'settings' => array(),
      'default_widget' => 'relation_default',
      'default_formatter' => 'relation_default',
      'instance_settings' => array('relation_type' => ''),
    ),
  );
}

/**
 * Implements hook_field_is_empty().
 */
function relation_dummy_field_field_is_empty($item, $field) {
  return FALSE;
}

/**
 * Implements hook_field_instance_settings_form().
 */
function relation_dummy_field_field_instance_settings_form($field, $instance) {
  $relation_types = relation_get_types();
  $bundle_key = $instance['entity_type'] . ':' . $instance['bundle'];
  $bundle_wildcard_key = $instance['entity_type'] . ':' . '*';
  $options = array();
  foreach ($relation_types as $relation_type => $relation_type_data) {
    foreach ($relation_type_data->source_bundles as $relation_bundle_key) {
      if ($bundle_key == $relation_bundle_key || $bundle_wildcard_key == $relation_bundle_key) {
        $options[$relation_type] = $relation_type_data->label;
      }
    }
  }
  $form['relation_type'] = array(
    '#type' => 'select',
    '#title' => t('Relation type'),
    '#default_value' => $instance['settings']['relation_type'],
    '#options' => $options,
  );
  return $form;
}

/**
 * Implements hook_field_widget_info().
 */
function relation_dummy_field_field_widget_info() {
  return array(
    'relation_default' => array(
      'label' => t('Relation dummy widget'),
      'field types' => array('relation'),
      'settings' => array(
        'size' => 60,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_form().
 */
function relation_dummy_field_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  // No edit. @TODO call the formatter.
  $relation_type = relation_type_load($instance['settings']['relation_type']);
  if (!$relation_type) {
    return $element;
  }
  // Very ugly but I can't find any other way to get hold of the entity.
  $entity = drupal_static('relation_dummy_field_field_widget_properties_alter');
  if ($entity) {
    list($entity_id) = entity_extract_ids($instance['entity_type'], $entity);
    if ($entity_id) {
      $has_data = relation_query($instance['entity_type'], $entity_id)
        ->propertyCondition('relation_type', $relation_type->relation_type)
        ->range(0, 1)
        ->count()
       ->execute();
      if ($has_data) {
        return $element;
      }
    }
  }
  list($entity_type, $bundle) = explode(':', $relation_type->source_bundles[0]);
  $entity_info = entity_get_info($entity_type);
  if (isset($entity_info['entity keys']['label'])) {
    $autocomplete_path = "relation_dummy_field/autocomplete/$entity_type/$bundle";
  }
  elseif ($entity_type == 'user') {
    $autocomplete_path = 'user/autocomplete';
  }
  else {
    // Sorry... can't continue.
    return $element;
  }

  $element += array(
    '#type' => 'textfield',
    '#default_value' => '',
    '#autocomplete_path' => $autocomplete_path,
    '#maxlength' => 1024,
  );
  return $element;
}

/**
 * Implementation of hook_field_widget_properties_alter().
 */
function relation_dummy_field_field_widget_properties_alter(&$widget, $context) {
  drupal_static_reset(__FUNCTION__);
  $static = &drupal_static(__FUNCTION__, new stdClass);
  $static = $context['entity'];
}

/**
 * Autocomplete page callback.
 */
function relation_dummy_field_autocomplete($entity_type, $bundle, $string = '') {
  $entity_info = entity_get_info($entity_type);
  $matches = array();
  if ($string && $entity_info && ($bundle == '*' || isset($entity_info['bundles'][$bundle]))) {
    $label_key = $entity_info['entity keys']['label'];
    $id_key = $entity_info['entity keys']['id'];
    $query = new EntityFieldQuery;
    $query
      ->entityCondition('entity_type', $entity_type)
      ->propertyCondition($label_key, $string, 'STARTS_WITH')
      ->range(0, 10);
    if ($bundle != '*') {
      $query->entityCondition('bundle', $bundle);
    }
    $result = $query->execute();
    if (!empty($result[$entity_type])) {
      $entities = entity_load($entity_type, array_keys($result[$entity_type]));
      foreach ($entities as $entity_id => $entity) {
        $label = check_plain($entity->$label_key);
        $label .= " [$id_key:$entity_id]";
        $matches[$label] = $label;
      }
    }
  }
  drupal_json_output($matches);
}

/**
 * Implements hook_field_update().
 */
function relation_dummy_field_field_update($entity_type, $entity, $field, $instance, $langcode, &$items) {
  // This runs on entity update if at first the relation wasn't created.
  relation_dummy_field_field_insert($entity_type, $entity, $field, $instance, $langcode, $items);
}

/**
 * Implements hook_field_insert().
 */
function relation_dummy_field_field_insert($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] != 'relation' || !$items) {
    return;
  }
  list($entity_id) = entity_extract_ids($entity_type, $entity);
  preg_match('/(\d+)\]$/', $items[0], $matches);
  // Empty out our items. Doesnt matter much because we do not have columns.
  $items = array();
  if (!$matches) {
    return;
  }
  $relation_type = relation_type_load($instance['settings']['relation_type']);
  list($relation_entity_type) = explode(':', $relation_type->source_bundles[0]);
  $entity_keys = array(
    array(
      'entity_type' => $entity_type,
      'entity_id'   => $entity_id,
      'r_index'     => 0,
    ),
    array(
      'entity_type' => $relation_entity_type,
      'entity_id'   => $matches[1],
      'r_index'     => 1,
    ),
  );
  $relation = relation_create($relation_type->relation_type, $entity_keys);
  relation_save($relation);
}

/**
 * Implements hook_field_formatter_info().
 */
function relation_dummy_field_field_formatter_info() {
  return array(
    'relation_default' => array(
      'label' => t('Default'),
      'field types' => array('relation'),
    ),
    'relation_otherendpoint' => array(
      'label' => t('Other endpoint'),
      'field types' => array('relation'),
    ),
    'relation_natural' => array(
      'label' => t('Natural language'),
      'field types' => array('relation'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function relation_dummy_field_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  list($entity_id) = entity_extract_ids($entity_type, $entity);
  switch ($display['type']) {
    case 'relation_default':
    case 'relation_otherendpoint':
      foreach ($items as $delta => $item) {
        $links = array();
        foreach ($item->endpoints[LANGUAGE_NONE] as $endpoint) {
          $related_entities = entity_load($endpoint['entity_type'], array($endpoint['entity_id']));
          $related_entity = reset($related_entities);
          if ($endpoint['entity_type'] == $entity_type && $endpoint['entity_id'] == $entity_id) {
            if ($display['type'] == 'relation_otherendpoint') {
              continue;
            }
            $link = array();
          }
          else {
            $link = entity_uri($endpoint['entity_type'], $related_entity);
            $link['href'] = $link['path'];
          }
          $link['title'] = entity_label($endpoint['entity_type'], $related_entity);
          $links[] = $link;
        }
        $uri = entity_uri('relation', $item);
        $relation_link = l(t('Relation @rid', array('@rid' => $item->rid)), $uri['path'], $uri['options']);
        // Can't use #heading as it's mercilessly check_plain'd.
        $element[$delta]['relation']['heading']['#markup'] = t('<h4>Part of !link</h4>', array('!link' => $relation_link));
        $element[$delta]['relation']['heading']['#access'] = $display['type'] == 'relation_default';
        $element[$delta]['relation']['links'] = array(
          '#theme' => 'links',
          '#links' => $links,
        );
      }
      break;

    case 'relation_natural':
      $sentences = array();
      foreach ($items as $delta => $item) {
        list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
        $relation_type = relation_type_load($item->relation_type);

        $subject = entity_label($entity_type, $entity) . ' '; // Subject of the sentence.
        $count = 0; // For comma separation of objects.
        $duplicate = FALSE; // To make sure duplicates of $entity get included in object list.
        $objects = ''; // Comma separated list of entities that are the object of the sentence.
        // Gramatical predicate of teh sentence.
        $predicate = $relation_type->directional ? $relation_type->reverse_label : $relation_type->label;

        foreach ($item->endpoints[LANGUAGE_NONE] as $endpoint) {
          // Add all entities that aren't this entity to the sentence $objects.
          // Check for duplicates of the $subject first.
          if ($endpoint['entity_type'] == $entity_type && $endpoint['entity_id'] == $id && $duplicate == FALSE) {
            $duplicate = TRUE;
            // Use the forward label as sentence predicate if r_index == 0.
            // (only makes a difference if relation is directional).
            if ($endpoint['r_index'] == 0) {
              $predicate = ' ' . $relation_type->label;
            }
          }
          else {
            $object_entities = entity_load($endpoint['entity_type'], array($endpoint['entity_id']));
            $object_entity = reset($object_entities);
            $object_label = entity_label($endpoint['entity_type'], $object_entity);
            $object_uri = entity_uri($endpoint['entity_type'], $object_entity);
            // Just add a space before the first element, comma and space before further ones.
            $objects .= $count ? ', ' : ' ';
            $count += 1;
            $objects .= l($object_label, $object_uri['path']);
          }
        }
        $element[$delta]['relation'] = array(
          '#theme' => 'item_list',
          '#items' => array($subject . $predicate . $objects),
        );
      }
      break;
  }

  return $element;
}

/**
 * Implements hook_field_prepare_view().
 */
function relation_dummy_field_field_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items, $displays) {
  foreach ($entities as $id => $entity) {
    $relation_ids = array_keys(relation_query($entity_type, $id)->execute());
    // Who knows why but field does not like if the delta does not start at 0...
    $items[$id] = $relation_ids ? array_values(entity_load('relation', $relation_ids)) : array();
  }
}
